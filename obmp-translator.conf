# enable/disable debug msgs
debug: true
# run program in the background or not
daemon: false


# translator uses the following kafka configs to retrieve raw bmp msgs produced by obmpv2.
librdkafka_consumer_config:
  # obmpv2 brokers that you wish to listen to
  obmpv2_brokers: "localhost:9092"
  # raw bmp topics that you want to subscribe
  raw_topics: "bmp_raw,bmp_raw_1,bmp_raw_2"


# translator uses the following kafka configs to produce parsed msgs that is identical to obmpv1 parsed msgs.
librdkafka_producer_config:

  ##################################################
  ### The following variables and values will be ###
  ###   directly passed to librdkafka            ###
  ### Consult with librdkafka documentation to   ###
  ###   configure your producer                  ###
  ##################################################

  # BROKER LIST
  #   For IPv6 use "[host or ip]:port".  Make sure to use double quotes for IPv6
  #   Can specify the protocol using <proto>://<host>[:port]
  #   Use comma to separate brokers (no space)
  #   e.g., metadata.broker.list: "localhost:9092,localhost:12345"
  metadata.broker.list: "localhost:9092"

  # message.max.bytes - Maximum transmit message size
  message.max.bytes: 1000000

  # receive.message.max.bytes - Maximum receive message size
  # The value should be at least
  # fetch.message.max.bytes * number of partitions consumed from i
  # + messaging overhead (e.g. 200000 bytes).
  receive.message.max.bytes: 200000000

  # Client group session and failure detection timeout in milliseconds
  session.timeout.ms: 10000

  # Timeout for network requests
  socket.timeout.ms: 30000

  # Maximum number of messages allowed on the producer queue.
  queue.buffering.max.messages: 100000

  # Maximum number of kbytes allowed on the producer queue. Range 1 - 2097151
  queue.buffering.max.kbytes: 1048576

  # Maximum time, in milliseconds, for buffering data on the producer queue.
  queue.buffering.max.ms: 100

  # How many times to retry sending a failing MessageSet.
  # Note: retrying may cause reordering.
  message.send.max.retries: 2

  # The backoff time in milliseconds before retrying a message send.
  retry.backoff.ms: 100

  # Compression codec to use for compressing message sets: none, gzip or snappy
  # By default it is set to snappy
  compression.codec: snappy

  api.version.request: true
  log.connection.close: false

kafka_topic_templates:
  # openbmp v1 topic templates
  openbmp_v1:
    # Use the following {{}} variables to partition topics
    #
    #   The following variables are generated at runtime
    #   router_group and peer_group are generated by the rules defined in "grouping" of this config file
    #   {{router_group}}:  organization-level information w.r.t. a bmp router.
    #                       constructed by the grouping criteria defined by you in this file.
    #   {{router_hostname}}: ip to hostname lookup, may not be resolvable.
    #   {{router_ip}}: bmp router ip
    #
    #   {{peer_group}}: organization-level information w.r.t. a bmp router's peer.
    #                       constructed by the grouping criteria defined by you in this file.
    #   {{peer_asn}}: from peer hdr
    #   {{peer_ip}}: from peer hdr
    #
    # topic templates
    collector: "collector"
    router: "{{router_group}}.router"
    peer: "{{router_group}}.{{peer_group}}.peer"
    unicast_prefix: "{{router_group}}.{{peer_group}}.unicast_prefix"


kafka_topic_templates_grouping:
  # router_group, order of matching
  #   matching order is performed in the following sequence. the first match found is used.
  #     regexp_hostname - hostname/regular expression is used first
  #     prefix_range    - prefix range is used second
  router_group:
    - name: "caida-bgpstream"
      prefix_range:
        - 192.133.197.1/32

    - name: "route-views.routeviews.org"
      regexp_hostname:
        - route-views\.routeviews\.org
      prefix_range:
        - 128.223.51.103/32

  # peer_group, order of matching
  #   matching order is performed in the following sequence. the first match found is used.
  #     regexp_hostname - hostname/regular expression is used first
  #     prefix_range    - prefix range is used second
  #     asn             - peer asn list
  peer_group:
    # name defines the value that is substituted for the variable.  This provides a consistent
    #    mapping for different IP's and hostnames
    - name: "lab"

      # You can define a list of regexp's that match for hostname to group mapping
      regexp_hostname:
        - .*\.lab\..*

      # You can also define a list of prefixes that match for ip to group mapping
      prefix_range:
        - 10.100.100.0/24
        - 10.100.104.0/24

      # You can define the matching to look at the peer asn.  This is only available for peer_groups.
      asn:
        - 100
        - 65000
        - 65001
